{
  "title": "Usando Collection - Parte 1",
  "article": "Usando Collection - Parte 1\nCollection\n \n\nUma estrutura de dados é uma coleção de dados organizados de alguma maneira. A estrutura não apenas armazena dados, mas também suporta operações para acessar e manipular os dados. O pacote java.util contém um dos subsistemas mais poderosos do Java: The Collections Framework. O Framework de coleções é uma hierarquia sofisticada de interfaces e classes que fornece tecnologia de ponta para gerenciar grupos de objetos.\n\nVocê pode executar as seguintes atividades usando a estrutura de coleta Java,\n\nAdicionar objetos à coleção\nRemover objetos da coleção\nProcurar um objeto na coleção\nRecuperar / obter objeto da coleção\nRepita a coleção para obter funcionalidades específicas da empresa.\n \nInterfaces-chave e classes de estrutura de Collection\ncoleção (c minúsculo): representa qualquer uma das estruturas de dados nas quais os objetos são armazenados e iterados.\nColeção (capital C): na verdade, é a interface java.util.Collection da qual Set, List e Queue se estendem.\nColeções (C maiúsculo e termina com s): é a classe java.util.Collections que mantém uma pilha de métodos de utilidade estática para uso com coleções.\n\n\nExistem algumas outras classes na estrutura de coleção que não estendem a Interface de Coleção, elas implementam a interface de Mapa.\n\n\n\nPodemos dizer que a coleção possui 4 tipos básicos:\n\nList:\nA interface List estende a Coleção para definir uma coleção ordenada com duplicatas permitidas. A interface List adiciona operações orientadas à posição, bem como um novo iterador de lista que permite ao usuário percorrer a lista bidirecionalmente. ArrayList, LinkedList e vector são classes que implementam a interface List.\nSet:\nA interface Set estende a interface Collection. Isso garantirá que uma instância de Set não contenha elementos duplicados. A classe concreta implementa códigos de hash e métodos iguais para garantir a exclusividade dos objetos. Três classes concretas de Set são HashSet, LinkedHashSet e TreeSet.\nMap:\nO Map é um contêiner que armazena os elementos junto com as chaves. As chaves são como índices. No List, os índices são números inteiros. No Map, as chaves podem ser qualquer objeto. O Map não pode conter chaves duplicadas. Cada chave é mapeada para um valor. Uma chave e seu valor correspondente de uma entrada, que é realmente armazenada em um mapa. HashMap, HashTable, TreeMap e LinkedHashMap são classes que implementam a interface do Map.\nQueue:\nQueue é uma estrutura de dados que entra e sai. Os elementos são anexados ao final da fila e são removidos do início da fila. Em uma fila de prioridades, os elementos recebem prioridades. Ao acessar elementos, o elemento com a maior prioridade é removido primeiro.\nPodemos ter subtipos de classes de coleção como classificadas, não-ordenadas, ordenadas e não-ordenadas.\n\nOrdenado: quando uma coleção é solicitada, significa que você pode percorrer a coleção em uma ordem específica (não aleatória)\nClassificação: uma coleção classificada significa que a ordem dos objetos na coleção é determinada de acordo com alguma regra ou regras, conhecida como ordem de classificação. Uma ordem de classificação não tem nada a ver com quando um objeto foi adicionado à coleção, ou quando foi a última vez que foi acessado ou em qual “posição” foi adicionada.\n \nInterface Iterator\nO Iterator permite percorrer uma coleção, obtendo ou removendo elementos. ListIterator estende o Iterator para permitir a passagem bidirecional de uma lista e a modificação de elementos.\n\nUm iterador é um objeto associado a uma coleção específica. Permite percorrer a coleção passo a passo. Existem dois métodos importantes do iterador.\n\nboolean hasNext(): Retorna true se houver pelo menos mais um elemento na coleção que está sendo percorrida. A chamada de Next () NÃO o move para o próximo elemento da coleção.\nobject next(): este método retorna o próximo objeto na coleção E move-o para frente até o elemento após o retorno do elemento.\n \nInterface do Comparator\nA interface Comparator oferece a capacidade de classificar uma determinada coleção de várias maneiras diferentes. A outra coisa útil sobre a interface do Comparator é que você pode usá-lo para classificar instâncias de qualquer classe - mesmo classes que não podem ser modificadas - ao contrário da interface Comparável, que o força a alterar a classe cujas instâncias você deseja classificar.\n\nA interface Comparator também é muito fácil de implementar, tendo apenas um método, compare () .O método Comparator.compare () retorna um int.\n\nAssinatura do método\nint compare (objOne, objTwo)\n\n\nO método Compare () retorna\n\nnegativo se objOne <objTwo\nzero se objOne == objTwo\npositivo se objOne> objTwo\n \nClasse ArrayList e Vector\nAlém da classe Arrays, o Java fornece uma classe ArrayList que pode ser usada para criar contêineres que armazenam listas de objetos. ArrayList pode ser considerado como uma matriz expansível. Oferece iteração rápida e acesso aleatório rápido. ArrayList implementa a nova interface RandomAccess - uma interface de marcador (o que significa que não possui métodos) que diz: “Esta lista suporta acesso aleatório rápido (geralmente em tempo constante)”. Escolha isso em um LinkedList quando você precisar de iteração rápida, mas provavelmente não fará muita inserção e exclusão.\n\nAs versões anteriores do Java possuem uma classe de coleção herdada chamada Vector, que é muito semelhante à ArrayList. O vetor implementa uma matriz dinâmica. Um vetor é basicamente o mesmo que um ArrayList, mas os métodos de vetor são sincronizados para segurança do encadeamento. Você normalmente deseja usar ArrayList em vez de Vector, porque os métodos sincronizados adicionam uma ocorrência de desempenho que talvez você não precise. \n\nA classe java.util.ArrayList é uma das classes mais comumente usadas no Framework Framework. A ArrayList é redimensionável dinamicamente, o que significa que seu tamanho pode mudar durante a execução do programa. Isso significa que:\n\nVocê pode adicionar um item a qualquer momento em um contêiner ArrayList e o tamanho da matriz se expande automaticamente para acomodar o novo item.\nVocê pode remover um item a qualquer momento em um contêiner ArrayList e o tamanho da matriz se contrai automaticamente.\nPara afirmar o óbvio: ArrayList é uma coleção ordenada (por índice), mas não classificada.\n\nPara usar a classe ArrayList, você deve usar a seguinte instrução de importação:\n \n\nimport java.util.ArrayList;\n\n \nEm seguida, para declarar um ArrayList, você pode usar o construtor padrão, como no exemplo a seguir:\n \n\nArrayList nomes = new ArrayList();\n\n \nO construtor padrão cria um ArrayList com capacidade para 10 itens. A capacidade de um ArrayList é o número de itens que ele pode armazenar sem precisar aumentar seu tamanho. Outros construtores de ArrayList da seguinte maneira,\n\nArrayList nomes = new ArrayList(int size);\n\nArrayList nomes = new ArrayList(Collection c);\n\n\nVocê também pode especificar a capacidade / tamanho do ArrayList inicial, bem como criar ArrayList a partir de outros tipos de coleção.\n\nAlgumas das vantagens que o ArrayList tem sobre os arrays são\n\nPode crescer dinamicamente.\nEle fornece mecanismos de inserção e pesquisa mais poderosos do que matrizes.\n \nMétodos ArrayList\n\n\nO seguinte programa demonstra o uso de todos os métodos descritos acima. Aqui estamos criando ArrayList chamado minhaLista e adicionando objetos usando o método add (), bem como usando o método add baseado em índice, e imprimindo todos os objetos usando o loop for. Então, demonstramos o uso dos métodos get (), contains () e size (). A saída do programa é mostrada abaixo do código Java.\n\n \n\nimport java.util.ArrayList;\n\npublic class ArrayListDemo {\n\npublic static void main(String[] args) {\n\n                               //declarando ArrayList de objetos String\n\n                               ArrayList<String> minhaLista = new ArrayList<String>();\n\n                               //Adicionando objetos à lista de matrizes no índice padrão\n\n                               minhaLista.add(“Maçã”);\n\n                               minhaLista.add(“Manga”);\n\n                               minhaLista.add(“Laranja”);\n\n                               minhaLista.add(“Uvas”);\n\n                               //Adicionando objeto a um índice específico\n\n                               minhaLista.add(1, “Laranja”);\n\n                               minhaLista.add(2,“Abacaxi”);\n\n                               System.out.println(“Mostrar todos os objetos:”);\n\n                               for(String s:minhaLista){\n\n                               System.out.println(s);\n\n                               }\n\n                               System.out.println(\"Adicionando objeto ao índice 3 \"+ minhaLista.get(3));\n\n                               System.out.println(\"Caqui está na lista: \" + minhaLista.contains(“Chicku”));\n\n                               System.out.println(\"Tamanho do ArrayList: \" + minhaLista.size());\n\n                               minhaLista.remove(“Papaya”);\n\n                               System.out.println(\"Novo tamanho do ArrayList: \"+ minhaLista.size());\n\n               }\n\n}\n\nResultado:\n\n\nClasse LinkedList\n\nUm LinkedList é ordenado pela posição do índice, como ArrayList, exceto que os elementos estão duplamente vinculados um ao outro. Esse vínculo fornece novos métodos (além do que você obtém da interface de lista) para adicionar e remover do início ou do fim, o que facilita a implementação de uma pilha ou fila. A lista vinculada tem um conceito de nós e dados. Aqui o Nó está armazenando valores do próximo nó enquanto os dados armazenam o valor que está mantendo. O diagrama abaixo mostra como o LinkedList armazena valores. Existem três elementos no LinkedList A, B e C. Estamos removendo o elemento B do meio do LinkedList que apenas vai alterar o valor do nó do elemento A para que aponte para o nó C.\n\n\nLembre-se de que um LinkedList pode iterar mais lentamente que um ArrayList, mas é uma boa opção quando você precisa de inserção e exclusão rápidas.\n\nO LinkedList tem os dois construtores mostrados aqui:\n \n\niLinkedList( )\n\nLinkedList(Collection<? extends E> c)\n\n\nO primeiro construtor cria uma lista vinculada vazia. O segundo construtor cria uma lista vinculada que é inicializada com os elementos da coleção c.\n\nMétodos importantes da classe LinkedList:\n\n\nNo seguinte programa demonstraremos o uso de todos os métodos descritos acima. Aqui, estamos criando o LinkedList chamado minhaLinkedList e adicionando objetos usando os métodos add (), addFirst () e addLast (), além de usar o método add () baseado em índice e imprimindo todos os objetos. Em seguida, modifique a lista usando os métodos remove (), removeLast () e remove (Object o). Em seguida, demonstramos o uso dos métodos getFirst () e getLast (). A saída do programa é mostrada abaixo do código Java.\n\n \n\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n\n               public static void main(String[] args) {\n\n                               LinkedList<String> minhaLinkedList = new LinkedList<String>();\n\n                               minhaLinkedList.addFirst(“A”);\n\n                               minhaLinkedList.add(“B”);\n\n                               minhaLinkedList.add(“C”);\n\n                               minhaLinkedList.add(“D”);\n\n                               minhaLinkedList.add(2, “X”);//adiciona C ao index 2\n\n                               minhaLinkedList.addLast(“Z”);\n\n                               System.out.println(“Lista antes de eliminar elementos”);\n\n                               System.out.println(minhaLinkedList);\n\n                               minhaLinkedList.remove();\n\n                               minhaLinkedList.removeLast();\n\n                               minhaLinkedList.remove(“C”);\n\n                               System.out.println(“Lista depois de eliminar o primeiro e o último objeto”);\n\n                               System.out.println(minhaLinkedList);\n\n                               System.out.println(\"Primeiro objeto: \"+ minhaLinkedList.getFirst());\n\n                               System.out.println(\"Último objeto: \"+ minhaLinkedList.peekLast());\n\n               }\n\n}\n\nResultado:\n\n\n\nHashSet\n\nUm conjunto é uma coleção que não pode conter elementos duplicados. Ele modela a abstração do conjunto matemático. O HashSet estende o AbstractSet e implementa a interface Set. Ele cria uma coleção que usa uma tabela de hash para armazenamento. Uma tabela de hash armazena informações usando um mecanismo chamado hash. No hash, o conteúdo informativo de uma chave é usado para determinar um valor exclusivo, chamado de código de hash. O código hash é então usado como o índice no qual os dados associados à chave são armazenados. A transformação da chave em seu código de hash é realizada automaticamente.\n\nQuando você coloca um objeto em um Hashset, ele usa o valor do código de hash do objeto para determinar onde colocar o objeto no conjunto. Mas também compara o código de hash do objeto com o código de hash de todos os outros objetos no conjunto de hash e, se não houver código de hash correspondente, o HashSet assume que esse novo objeto não é uma duplicata. O HashSet localiza um código de hash correspondente para dois objetos. um que você está inserindo e outro que já está no conjunto - o HashSet chamará um dos métodos equals () do objeto para verificar se esses objetos correspondentes a hashcode são realmente iguais. E se forem iguais, o HashSet sabe que o objeto que você está tentando adicionar é uma duplicata de algo no Conjunto, para que o add não aconteça.\n\nUm HashSet é um conjunto não classificado e não ordenado. Ele usa o código de hash do objeto que está sendo inserido, portanto, quanto mais eficiente sua implementação de hashCode (), melhor o desempenho de acesso que você terá. Use essa classe quando desejar uma coleção sem duplicatas e não se importar com a ordem, ao iterá-lo.\n \n\nHashSet () // Construtor padrão\n\nHashSet (Collection c) // Cria o HashSet a partir da coleção c\n\nHashSet (int capacidade) // cria o HashSet com a capacidade inicial mencionada\n\n \n\n \n\nHashSet (int capacidade, float carregaFator) // Cria o HashSet com capacidade e fator de carga\n\nEscolher uma capacidade inicial muito alta pode desperdiçar espaço e tempo. Por outro lado, escolher uma capacidade inicial muito baixa desperdiça tempo ao copiar a estrutura de dados cada vez que é forçado a aumentar sua capacidade. Se você não especificar uma capacidade inicial, o padrão é 16.\n\nA classe HashSet possui outro parâmetro de ajuste chamado fator de carga. O tamanho do HashSet aumenta conforme o fator de carga definido ou o tamanho duplo padrão.\n \n\nMétodos HashSet\n\n\nimport java.util.HashSet;\n\npublic class HashSetDemo {\n\npublic static void main(String[] args) {\n\n               HashSet<String> hs = new HashSet<String>();\n\n               // Adicionando elementos ao HashSet\n\n               hs.add(“M”);\n\n                                              hs.add(“B”);\n\n                                              hs.add(“C”);\n\n                                              hs.add(“A”);\n\n                                              hs.add(“M”);\n\n                                              hs.add(“X”);\n\n                                              System.out.println(\"Tamanho do HashSet=\" + hs.size());\n\n                                              System.out.println(\"HashSet Original:\" + hs);\n\n                                              System.out.println(\"Remover A do HashSet: \" + hs.remove(“A”));\n\n                                              System.out.println(\"Tentando remover Z, o qual não está presente: \"\n\n                                                                            + hs.remove(“Z”));\n\n                                              System.out.println(“Verificando se M está presente=” + hs.contains(“M”));\n\n                                              System.out.println(\"HashSet atualizado: \" + hs);\n\n               }\n\n}\n\nResultado:\n\n\nTreeSet\n\nO TreeSet é uma das duas coleções classificadas (a outra é o TreeMap). O TreeSet estende o AbstractSet e implementa a interface NavigableSet. Ele cria uma coleção que usa uma árvore para armazenamento. Os objetos são armazenados em ordem crescente e ordenada, de acordo com a ordem natural. Opcionalmente, você pode construir um TreeSet com um construtor que permita dar à coleção suas próprias regras para o que o pedido deve ser (em vez de depender da ordem definida pela classe dos elementos) usando um Comparable ou Comparator.\n\nOs tempos de acesso e recuperação são bastante rápidos, o que torna o TreeSet uma excelente opção ao armazenar grandes quantidades de informações classificadas que devem ser encontradas rapidamente. O TreeSet pode não ser usado quando nosso aplicativo requer modificação do conjunto em termos de adição frequente de elementos.\n\n \n\nConstrutores\n\nTreeSet (); // Construtor padrão\n\nTreeSet(Collection<? extends E> c);// TreeSet da coleção C\n\nTreeSet(Comparator<? super E> comp); // TreeSet com pedidos personalizados conforme o comparador\n\nTreeSet (SortedSet <E> ss); // TreeSet que contém os elementos de ss.\n\n\nMétodos importantes da classe TreeSet\n\n\n\nimport java.util.TreeSet;\n\npublic class TreeSetDemo {\n\n               public static void main(String[] args) {\n\n               TreeSet<String> playerSet = new TreeSet<String>();\n\n               playerSet.add(“Sonia”);\n\n               playerSet.add(“Zelia”);\n\n               playerSet.add(“Marcos”);\n\n               playerSet.add(“Belém”);\n\n               playerSet.add(“Verônica”);\n\n               playerSet.add(“Juliana”);\n\n               playerSet.add(“Ismael”);\n\n               playerSet.add(“Uriel”);\n\n               playerSet.add(“Pedro”);\n\n               playerSet.add(“Vanessa”);\n\n               playerSet.add(“Sonia”); // Esse é um elemento duplicado, logo, não será adicionado novamente         \n\n//abaixo imprimirá a lista em ordem alfabética\n\n               System.out.println(“Set Original:” + playerSet);\n\n               System.out.println(\"Primeiro Nome: \"+ playerSet.first());\n\n               System.out.println(\"Último Nome: \"+ playerSet.last());\n\n               TreeSet<String> newPlySet = (TreeSet<String>) playerSet.subSet(“Marcos”, “Vanessa”);\n\n               System.out.println(\"Sub set \"+ newPlySet);\n\n               }\n\n}\n\nResultado:\n\n\nNo exemplo acima, estamos criando o objeto TreeSet of String. A classe String está tendo uma interface comparável implementada pela biblioteca Java. Vamos pensar em um caso em que precisamos ter nossos próprios objetos para serem armazenados em Set e ordenar objetos de acordo com nossa regra. O exemplo abaixo mostra Cricketers como um objeto com duas propriedades name e battingPosicao. Queremos armazenar todos os objetos Cricketers de acordo com a posição definida de batedura, quando iteramos através da coleção e obtemos nomes de acordo com a posição de batedura.\n \n\nCódigo Java (Cricketer.java)\n\npackage br.com.java.aula;\n\npublic class Cricketer {\n\n               private String nome;\n\n               private int battingPosicao;\n\n               Cricketer(String cricketerNome, int cBattingPosicao){\n\n                               this.nome = cricketerName;\n\n                               this.battingPosicao = cBattingPosicao;\n\n               }\n\n               public String getName() {\n\n                               return nome;\n\n               }\n\n               public int getBattingPosicao() {\n\n                               return battingPosicao;\n\n               }\n\n}\n\nCódigo Java (CompareCricketer.java)\n\n            Aqui estamos definindo regras de como organizar objetos Cricketer no TreeMap.\n \n\npackage br.com.java.aula;\n\nimport java.util.Comparator;\n\npublic class CompareCricketer implements Comparator <Cricketer> {\n\n               @Override\n\n               public int compare(Cricketer arg0, Cricketer arg1) {\n\n                               if(arg0.getBattingPosicao() > arg1.getBattingPosicao())\n\n                                              return 1;\n\n                               else if (arg0.getBattingPosicao() < arg1.getBattingPosicao())\n\n                                              return -1;\n\n                               else return 0;\n\n               }\n\n}\n\npackage br.com.java.aula;\n\nimport java.util.Iterator;\n\nimport java.util.TreeSet;\n\npublic class CustomTreeSetDemo {\n\n public static void main(String[] args) {\n\n               TreeSet<Cricketer> playerSet = new TreeSet<Cricketer>(\n\n               new CompareCricketer());\n\n               playerSet.add(new Cricketer(“Sonia”, 1));\n\n               playerSet.add(new Cricketer(“Zelia”, 9));\n\n               playerSet.add(new Cricketer(“Marcos”, 7));\n\n               playerSet.add(new Cricketer(“Belém”, 8));\n\n               playerSet.add(new Cricketer(“Verônica”, 2));\n\n               playerSet.add(new Cricketer(“Juliana”, 4));\n\n               playerSet.add(new Cricketer(“Ismael”, 10));\n\n               playerSet.add(new Cricketer(“Uriel”, 11));\n\n               playerSet.add(new Cricketer(“Pedro”, 5));\n\n               playerSet.add(new Cricketer(“Vanessa”, 3));\n\n               playerSet.add(new Cricketer(“Raina”, 6));\n\n               Iterator<Cricketer> it = playerSet.iterator();\n\n               while (it.hasNext()) {\n\n               System.out.println(it.next().getName());\n\n    }\n\n  }\n\n}\n\nResultado:\n\n\nLinkedHashSet\n\nUm LinkedHashSet é uma versão ordenada do HashSet que mantém uma lista duplamente vinculada em todos os elementos. Use esta classe em vez do HashSet quando se importar com a ordem da iteração. Quando você itera através de um HashSet, a ordem é imprevisível, enquanto um LinkedHashSet permite iterar pelos elementos na ordem em que foram inseridos. Ao percorrer o LinkedHashSet usando um iterador, os elementos serão retornados na ordem em que foram inseridos.\n \n\nConstrutores LinkedHashSet\n\nLinkedHashSet () // Construtor padrão\n\nLinkedHashSet (Collection c) // Cria LinkedHashSet a partir da coleção c\n\nLinkedHashSet (int capacidade) // cria LinkedHashSet com a capacidade inicial mencionada\n\nLinkedHashSet (int capacidade, float carregaFator) // Isso cria o LinkedHashSet com capacidade e fator de carga\n\n\nMétodos LinkedHashSet\n\n\nimport java.util.LinkedHashSet;\n\npublic class LinkedHashSetDemo {\n\n               public static void main(String[] args) {\n\n                               LinkedHashSet<String> linkedset = new LinkedHashSet<String>();\n\n                               // Adicionando elementos ao LinkedHashSet\n\n                               linkedset.add(“Maruti”);\n\n                               linkedset.add(“BMW”);\n\n                               linkedset.add(“Honda”);\n\n                               linkedset.add(“Audi”);\n\n                               linkedset.add(“Maruti”); //Esse não adicionará o novo elemento pois Maruti já existe.\n\n                               linkedset.add(“WalksWagon”);\n\n                               System.out.println(“Tamanho do LinkedHashSet=” + linkedset.size());\n\n                               System.out.println(“LinkedHashSet Original:” + linkedset);\n\n                               System.out.println(\"Removendo Audi do LinkedHashSet: \" + linkedset.remove(“Audi”));\n\n                               System.out.println(\"Tentando remover Z, o qual não está presente: \"\n\n                                                             + linkedset.remove(“Z”));\n\n                               System.out.println(“Verificando se Maruti está presente=” + linkedset.contains(“Maruti”));\n\n                               System.out.println(\"LinkedHashSet atualizada: \" + linkedset);\n\n               }\n\n}\n\nResultado:\n\n\nPodemos usar o objeto Iterator para iterar através de nossa coleção. Enquanto iteramos, podemos adicionar ou remover objetos da coleção. O programa abaixo demonstra o uso do iterador na coleção LinkedHashSet.\n \n\npackage br.com.java.aula;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.Set;\n\npublic class LinkedHashSetIterator {\n\n               public static void main(String[] args) {\n\n                               Set<String> meuCricketerSet = new LinkedHashSet<String>();\n\n                               meuCricketerSet.add(“Ariel”);\n\n                               meuCricketerSet.add(“Daniela”);\n\n                               meuCricketerSet.add(“Jussara”);\n\n                               meuCricketerSet.add(“Benjamin”);\n\n                               meuCricketerSet.add(“Flavio”);\n\n                               meuCricketerSet.add(“Marcio”);\n\n                               meuCricketerSet.add(“Valeria”);\n\n                               meuCricketerSet.add(“Ramon”);\n\n                               Iterator<String> setIterator = meuCricketerSet.iterator();\n\n                               while(setIterator.hasNext()){\n\n                               System.out.println(setIterator.next());\n\n               }\n\n}\n\nResultado:\n\n\nAtividade extra\n\nVídeo: “Collections em Java Quando usar List, Map e Set”\nLink: https://www.youtube.com/watch?v=Mr_1bbMD53I\n\n \n\n \n\n \n\nReferências Bibliográficas\n\n \n\nBARNES, D. J. KOLLING, M. Programação orientada a objetos com java: uma introdução prática usando o bluej. 4.ed. Pearson: 2009.\n\nFELIX, R. (Org.). Programação orientada a objetos. Pearson: 2017.\n\nMEDEIROS, L. F. de. Banco de dados: princípios e prática. Intersaberes: 2013;\n\nORACLE. Java Documentation, 2021. Documentação oficial da plataforma Java. Disponível em: < https://docs.oracle.com/en/java/ >.\n",
  "exercises": "01\nDefina a função do Framework de coleções (The Collections Framework)\n\nA) É uma hierarquia sofisticada de interfaces e variáveis que fornece tecnologia de ponta para gerenciar grupos de objetos\nB) É uma hierarquia sofisticada de variáveis e classes que fornece tecnologia de ponta para gerenciar grupos de objetos\nC) É uma hierarquia sofisticada de métodos e classes que fornece tecnologia de ponta para gerenciar grupos de variáveis\nD) É uma hierarquia sofisticada de interfaces e classes que fornece tecnologia de ponta para gerenciar grupos de objetos\nE) É uma hierarquia sofisticada de interfaces que fornece tecnologia de ponta para gerenciar grupos de objetos\n\n02\nQual das classes abaixo não é uma implementação da interface List?\n\nA) ​ArrayList​\nB) ​LinkedList​\nC) ​Vector​\nD) ​SortedMap​\nE) ​Todas as classes acima implementam a interface List​\n\n03\n​O ArrayList é uma classe que permite a fácil estruturação e manipulação de dados em uma lista. Considerando os métodos disponíveis nesta classe, qual das alternativas não é um método válido?​\n\nA) ​add()​\nB) ​remove()​\nC) ​insert()​\nD) ​get()​\nE) ​size()​\n\n04\n​Quais são os 4 tipos básicos de coleção?​\n\nA) ​List, Set, Map, Queue​\nB) ​Var, Set, Map, Queue​\nC) ​List, Function, Map, Queue​\nD) ​Var, Set, Map, Class​\nE) ​Set, Map, Array, ArrayList​\n\n05\n​Sobre a classe ArrayList é correto afirmar que:​\n\nA) ​Pode ser considerada como uma matriz expansível usada para criar contêineres que armazenam listas de objetos​\nB) ​Pode ser considerada como uma coleção expansível usada para criar contêineres que armazenam listas de objetos​\nC) ​Pode ser considerada como uma matriz expansível usada para criar contêineres que armazenam listas de classes​\nD) ​Pode ser considerada como uma matriz expansível usada para criar contêineres que armazenam listas de variáveis​\nE) ​Pode ser considerada como uma matriz expansível usada para criar contêineres que armazenam listas de interfaces​\n\n06\nA interface Collection é a base sobre a qual a estrutura de coleções é construída. Ele declara os métodos principais que todas as coleções terão.Também temos a interface List, que estende de Collection, na qual possui as classes Vector e ArrayList. Cada classe tem a sua particularidade e deve ser usada em momentos bem definidos.Imagine que você tem uma situação em que precisa se preocupar com a performance de sua aplicação. Com isso, é importante saber as características de cada classe para ser usada de forma adequada\n\nDesta forma. identifique nas opções abaixo o que melhor define a diferença entre Vector e ArrayList:\n\nA) ​O vetor implementa uma matriz estática, os métodos de vetor são sincronizados para segurança do encadeamento. Os programadores costumam preferir usar ArrayList em vez de Vector, porque os métodos sincronizados adicionam uma ocorrência de desempenho que talvez você não precise​\nB) O vetor implementa uma matriz dinâmica, os métodos de vetor não podem ser sincronizados\nC) ​O vetor implementa uma matriz dinâmica, os métodos de vetor são sincronizados para segurança do encadeamento. Os programadores costumam preferir usar ArrayList em vez de Vector, porque os métodos sincronizados adicionam uma ocorrência de desempenho que talvez você não precise​\nD) ​O vetor implementa uma matriz estática, os métodos de vetor são sincronizados para segurança do encadeamento​\nE) ​O vetor implementa uma matriz dinâmica e estática, os métodos de vetor são sincronizados para segurança do encadeamento​\n"
}